<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Bowen&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Bowen&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Bowen&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Bowen Zhang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Bowen's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Bowen&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-对象存储实战指南学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-05-31T06:29:36.000Z" itemprop="datePublished">2023-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">对象存储实战指南学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><h2 id="1-对象存储概述"><a href="#1-对象存储概述" class="headerlink" title="1.对象存储概述"></a>1.对象存储概述</h2><h3 id="1-1-存储技术对比："><a href="#1-1-存储技术对比：" class="headerlink" title="1.1 存储技术对比："></a>1.1 存储技术对比：</h3><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">块存储</th>
<th align="left">文件存储</th>
<th align="left">对象存储</th>
</tr>
</thead>
<tbody><tr>
<td align="left">适用范围<br>（网络边界）</td>
<td align="left">数据中心内</td>
<td align="left">数据中心内</td>
<td align="left">互联网、移动互联网（3G&#x2F;4G&#x2F;5G）<br>数据中心内</td>
</tr>
<tr>
<td align="left">使用者<br>（用户）</td>
<td align="left">机器</td>
<td align="left">办公帐号（AD&#x2F;LDAP）<br>机器</td>
<td align="left">云账号、社交帐号<br>兼容办公帐号<br>机器</td>
</tr>
<tr>
<td align="left">访问协议&#x2F;接口</td>
<td align="left">快协议<br>（ATA&#x2F;SCSI）</td>
<td align="left">文件协议<br>（NFS&#x2F;CIFS&#x2F;SMB）</td>
<td align="left">对象接口<br>（S3&#x2F;Blob&#x2F;OSS）</td>
</tr>
<tr>
<td align="left">后端技术</td>
<td align="left">Drive、DAS、SAN</td>
<td align="left">File System、NAS</td>
<td align="left">Object Storage</td>
</tr>
<tr>
<td align="left">特点</td>
<td align="left">机机交互</td>
<td align="left">人机交互<br>机机交互</td>
<td align="left">移动互联网交互<br>人机交互<br>机机交互</td>
</tr>
</tbody></table>
<h4 id="后端技术："><a href="#后端技术：" class="headerlink" title="后端技术："></a>后端技术：</h4><p>块存储：采用线性地址空间管理地址块，为主机提供指定容量空概念的访问。<br>文件存储：使用树来管理目录和文件的层级结构，目录类似树的中间节点，文件类似书的叶子节点，从而实现灵活的文件管理。<br>对象存储：采用桶和对象模型，在桶内采用平坦模式管理对象，提供线性扩展能力。</p>
<h3 id="1-2-存储技术架构"><a href="#1-2-存储技术架构" class="headerlink" title="1.2 存储技术架构"></a>1.2 存储技术架构</h3><h4 id="存储区域网络（SAN-Storage-Area-Network）–块存储"><a href="#存储区域网络（SAN-Storage-Area-Network）–块存储" class="headerlink" title="存储区域网络（SAN Storage Area Network）–块存储"></a>存储区域网络（SAN Storage Area Network）–块存储</h4><h4 id="网络附加存储（NAS-Network-Attached-Storage）–文件存储"><a href="#网络附加存储（NAS-Network-Attached-Storage）–文件存储" class="headerlink" title="网络附加存储（NAS Network Attached Storage）–文件存储"></a>网络附加存储（NAS Network Attached Storage）–文件存储</h4><h4 id="对象存储架构（Object-Storage）"><a href="#对象存储架构（Object-Storage）" class="headerlink" title="对象存储架构（Object Storage）"></a>对象存储架构（Object Storage）</h4><h3 id="1-3-公共云对象存储服务"><a href="#1-3-公共云对象存储服务" class="headerlink" title="1.3 公共云对象存储服务"></a>1.3 公共云对象存储服务</h3><h4 id="1-3-1-架构"><a href="#1-3-1-架构" class="headerlink" title="1.3.1 架构"></a>1.3.1 架构</h4><h5 id="3层架构（基于分布式文件系统构建）"><a href="#3层架构（基于分布式文件系统构建）" class="headerlink" title="3层架构（基于分布式文件系统构建）"></a>3层架构（基于分布式文件系统构建）</h5><p>逻辑视图（从下到上）：分布式文件系统（HDFS）、索引元数据（分布式键值存储，如HBASE）、对象服务功能 —–Google Cloud Storage、Aliyun OSS</p>
<h5 id="2层架构（基于本地键值存储构建）"><a href="#2层架构（基于本地键值存储构建）" class="headerlink" title="2层架构（基于本地键值存储构建）"></a>2层架构（基于本地键值存储构建）</h5><p>逻辑视图（从下到上）：分布式键值存储、对象服务功能 —-Ceph</p>
<h4 id="1-3-2-关键能力"><a href="#1-3-2-关键能力" class="headerlink" title="1.3.2 关键能力"></a>1.3.2 关键能力</h4><p>按优先级从高到底：<br><strong>安全性：数据加密</strong><br><strong>高可靠：协调和复制，容错和数据完整性</strong><br><strong>高可用：数据保护</strong><br><strong>扩展性：命名和同步</strong>，<strong>元数据索引设计</strong>，<strong>数据迁移</strong><br><strong>性价比：数据生命周期</strong></p>
<h2 id="2-协调（Coordination）和复制（Replication）"><a href="#2-协调（Coordination）和复制（Replication）" class="headerlink" title="2.协调（Coordination）和复制（Replication）"></a>2.协调（Coordination）和复制（Replication）</h2><p><img src="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%85%B1%E8%AF%86.jpg" alt="共识和复制对比"></p>
<p>在分布式系统中通过协调达成共识是普遍需求，部署在多台服务器间的进程都需要通信协调将关键数据达成一致。两将军首次提出不可靠网络的共识问题，然后演化为存在拜占庭故障的拜占庭将军问题，通过对问题的分析提出原子广播解决方案（Atomic Broadcast，ABCAST），鉴于原子广播无法支撑数据持久化能力，业界提出改进优化的视图复制（Viewstamped Replication，<strong>VR</strong>）和<strong>PAXOS</strong>，鉴于PAXOS的理论复杂度，业界又提出RAFT，它将PAXOS用更简单的方式描述，同时参考VR的工程实现优化。</p>
<p>共识技术要支持数据持久化能力会用到日志复制技术，而分布式存储系统需要做数据冗余也需要实现数据复制。</p>
<h3 id="2-1-协调"><a href="#2-1-协调" class="headerlink" title="2.1 协调"></a>2.1 协调</h3><p>两将军问题，采用固定次数的消息确认，解决通信网络不可靠时的共识问题。—-TCP&#x2F;IP三次握手<br>拜占庭将军问题，两种解决。1）根据分布式系统的服务器总数，限定发生拜占庭故障的服务器数。2）根据数字签名识别伪装的服务器，或根据序列号识别亚健康服务器的错误消息</p>
<p><strong>共识算法解决的核心问题是系统成员正常时如何解决多个请求提案的顺序处理问题并保证每个提案能够被系统成员投票达成一致，以及系统成员异常时如何重新选取成员并让系统重新进入正常状态。</strong></p>
<h4 id="VR-架构包含副本和客户端"><a href="#VR-架构包含副本和客户端" class="headerlink" title="VR 架构包含副本和客户端"></a>VR 架构包含副本和客户端</h4><p>VR在发生成员故障后，会在正常的副本中选主：</p>
<ul>
<li>选主是基于日志做恢复。</li>
<li>选主会基于视图的逻辑时钟序号和<strong>日志顺序号</strong>完成。</li>
<li>客户端复制代理发送请求时会携带缓存的<strong>视图序号</strong>，主会比对本地视图序号和请求视图序号，只有相同才允许执行，从而避免视图切换时请求到不匹配的数据。</li>
</ul>
<h4 id="PAXOS-架构组件：客户端，接收者（Accepter-x2F-Voter），提案者（Proposer），学习者（Learner），领导者（Leader）"><a href="#PAXOS-架构组件：客户端，接收者（Accepter-x2F-Voter），提案者（Proposer），学习者（Learner），领导者（Leader）" class="headerlink" title="PAXOS 架构组件：客户端，接收者（Accepter&#x2F;Voter），提案者（Proposer），学习者（Learner），领导者（Leader）"></a>PAXOS 架构组件：客户端，接收者（Accepter&#x2F;Voter），提案者（Proposer），学习者（Learner），领导者（Leader）</h4><p>VR的副本和PAXOS的成员（提案者、接收者、学习者）对应，VR的主和PAXOS的领导者对应。VR用重配置（Reconfiguration）重新选主，PAXOS用提案者扮演领导者实现选主。</p>
<p>阿里云对象存储依赖女娲共识服务。</p>
<h3 id="2-2-复制"><a href="#2-2-复制" class="headerlink" title="2.2 复制"></a>2.2 复制</h3><h4 id="2-2-1数据冗余技术：副本；RAID；纠删码。"><a href="#2-2-1数据冗余技术：副本；RAID；纠删码。" class="headerlink" title="2.2.1数据冗余技术：副本；RAID；纠删码。"></a>2.2.1数据冗余技术：副本；RAID；纠删码。</h4><h4 id="2-2-2一致性"><a href="#2-2-2一致性" class="headerlink" title="2.2.2一致性"></a>2.2.2一致性</h4><p>两个术语：<br>-<strong>CAP</strong>：<em>C一致性（Consistency，读请求应该得到最新写入数据，或者返回错误），A可用性（Availability，读&#x2F;写请求尽量得到响应，读可以不用返回最新写入数据），P表示分区容错能力（Partition tolerance，网络节点丢包后系统能够继续工作）。</em>常用于分布式系统，最终一致性（BASE）选择满足A和P而牺牲C。<br>-<strong>ACID</strong>：常用于数据库系统。</p>
<p>一致性模型：<br>-客服端一致性模型<br>-服务端数据副本一致性模型</p>
<h4 id="2-2-3复制协议"><a href="#2-2-3复制协议" class="headerlink" title="2.2.3复制协议"></a>2.2.3复制协议</h4><p>-基于主复制协议<br>至少2跳，第1跳由客户端发送请求给主，第2跳由主并行将请求发给多个副本。时延长，无并发冲突。<br>-客户端写复制协议<br>1跳，客户端并行发送给多个副本。时延短，有并发冲突。</p>
<h4 id="2-2-4存储领域的复制技术"><a href="#2-2-4存储领域的复制技术" class="headerlink" title="2.2.4存储领域的复制技术"></a>2.2.4存储领域的复制技术</h4><h5 id="SAN-x2F-NAS的复制技术"><a href="#SAN-x2F-NAS的复制技术" class="headerlink" title="SAN&#x2F;NAS的复制技术"></a>SAN&#x2F;NAS的复制技术</h5><p>按复制时间点分为基于快照的复制和基于IO日志的复制。<br>按复制位置分为同步复制和异步复制。</p>
<h5 id="对象存储的复制技术"><a href="#对象存储的复制技术" class="headerlink" title="对象存储的复制技术"></a>对象存储的复制技术</h5><p>CEPH的对象存储构建在底层<strong>RADOS</strong>（Reliable Autonomic Distributed Object Store）技术上，其核心是基于<strong>OSD</strong>（Object Storage Device）的数据复制。OSD基于主复制协议。</p>
<h2 id="3-命名和同步"><a href="#3-命名和同步" class="headerlink" title="3.命名和同步"></a>3.命名和同步</h2><p><img src="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%91%BD%E5%90%8D%E5%92%8C%E5%90%8C%E6%AD%A5.png" alt="命名和同步"></p>
<p>对象存储通过<strong>命名技术</strong>管理分布式系统的海量服务器，通过<strong>物理时钟</strong>实现大规模服务期间的<strong>时钟同步</strong>，通过<strong>逻辑时钟</strong>实现大规模服务器间的<strong>时序、数据同步</strong>。</p>
<h3 id="3-1-命名"><a href="#3-1-命名" class="headerlink" title="3.1 命名"></a>3.1 命名</h3><p>对象存储综合应用了<strong>结构化命名、平坦命名，基于属性命名技术</strong>。<br>-<strong>平坦命名</strong>（非结构化命名）：IPV4（32位）&#x2F;IPV6（128位）、MAC地址（48位）、UUID（128位）。<br>-<strong>结构化命名</strong>：URL。（类似树形结构）<br>-<strong>基于属性命名</strong>：情形目录访问协议（Lightweight Directory Access Protocol，LDAP），记录多维度属性。</p>
<p>例子：<br>客户端请求访问“image-demo.oss-cn-hangzhou.aliyuncs.com&#x2F;example.jpg”对象时：<br>（1）<strong>DNS域名解析</strong>：解析URL的主机名image-demo.oss-cn-hangzhou.aliyuncs.com，得到对象存储主机的IP地址。<br>（2）客户端将请求包发送到指定IPv4地址的机器（服务器X），同时包含完整的URL名。X将请求和URL发送到对象存储的后端服务器（服务器B）。<br>（3）服务器B通过传入的URL得到对象名example.jpg，按照<strong>平坦空间寻址方法</strong><em>（按范围分区的字节比对查找和按哈希分区的计算查找）</em>找到数据所在硬盘的UUID。<br>（4）根据对象名example.jpg对应的硬盘的<strong>UUID</strong>，就可以取回数据。<br>（5）对象存储支持标签功能。标签按照<strong>基于属性命名</strong>技术组织，提供Key-Value键值对，为对象提供更多维度的信息。</p>
<h3 id="3-2-同步"><a href="#3-2-同步" class="headerlink" title="3.2 同步"></a>3.2 同步</h3><h4 id="3-2-1-物理时钟"><a href="#3-2-1-物理时钟" class="headerlink" title="3.2.1 物理时钟"></a>3.2.1 物理时钟</h4><p>对象存储云服务中的服务器之间通常基于网络时间协议（Network Time Protocol， NTP），即基于网络包交换实现计算机系统间的时钟同步协议，位于OSI模型的应用层。</p>
<h4 id="3-2-2-逻辑时钟"><a href="#3-2-2-逻辑时钟" class="headerlink" title="3.2.2 逻辑时钟"></a>3.2.2 逻辑时钟</h4><p>对象存储通常使用逻辑时钟来提供序号，为多节点的交互控制提供时许控制，保证请求的顺序性。</p>
<p>例子：<br><strong>CEPH</strong>对于并发写请求，通过<strong>主OSD</strong>的ObjectStore::Sequencer递增序号来实现逻辑时钟，为每个客户端发送过来的写请求分配序号，然后主OSD将写请求复制到多个<strong>从OSD</strong>，并使用该序号作为并发请求的先后顺序，保证请求在多个从OSD上的顺序性。</p>
<h2 id="4-容错和数据完整性"><a href="#4-容错和数据完整性" class="headerlink" title="4.容错和数据完整性"></a>4.容错和数据完整性</h2><p><strong>容错设计提升系统可用性，数据完整性提升系统的数据持久度。</strong></p>
<h3 id="4-1容错"><a href="#4-1容错" class="headerlink" title="4.1容错"></a>4.1容错</h3><p><img src="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%B9%E9%94%99.png" alt="容错概念点"></p>
<p><strong>容错（Fault Tolerance）</strong>是指部件出现故障后，系统仍然能够继续工作。</p>
<p>分布式系统的容错设计与存储区域网络（SAN）和网络附加存储（NAS）的双控（Dual Controller）系统容错思路不同。<strong>“不再通过单服务器内部件冗余提升可靠性，而是搭建多服务器系统使整体达到高可靠性”。</strong></p>
<h3 id="4-2数据完整性"><a href="#4-2数据完整性" class="headerlink" title="4.2数据完整性"></a>4.2数据完整性</h3><p><img src="/./%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7.png" alt="数据完整性概念点"></p>
<p><strong>Data Integrity</strong>: Secure（物理层面的安全），Accurate、Consistent、Complete（逻辑层面的正确、一致、完备）</p>
<p>从<strong>物理完整性</strong>看，要通过类似纠删码（Erasure Code，EC）的冗余技术来实现数据损坏的修复；从<strong>逻辑完整性</strong>看，要通过业务、应用层的保护机制实现数据损坏的修复，如数据复制和备份。</p>
<p><strong>对象存储数据损坏</strong>：<br><strong>运行时刻</strong>时通过端到端的循环冗余校验检测数据损坏：数据上传时；数据存储时校验数据和元数据（分片保存）；写入磁盘前。<br><strong>静态时刻</strong>时利用磁盘上的分布式存储模块（如HDFS）进行静态数据扫描，读取保存的数据和保存校验值，然后CPU通过计算保存数据得到计算的校验值，两个校验值比对。</p>
<h2 id="5-元数据索引设计"><a href="#5-元数据索引设计" class="headerlink" title="5.元数据索引设计"></a>5.元数据索引设计</h2><p><img src="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8.png" alt="元数据索引设计"></p>
<p>元数据索引是为公共云对象存储服务提供键值管理的核心技术，它需要提供<strong>变长</strong>的空间管理和弹性扩展能力。</p>
<p><strong>对象存储的元数据管理的关键在于存储空间（Bucket）&#x2F;对象（Object）的写&#x2F;读&#x2F;删除&#x2F;遍历操作，没有复杂查询需求。</strong></p>
<p>几种NoSQL数据模型对比：</p>
<table>
<thead>
<tr>
<th align="left">数据模型</th>
<th align="left">性能</th>
<th align="left">拓展性</th>
<th align="left">灵活性</th>
<th align="left">复杂度</th>
<th align="left">功能性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">键值存储</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">可选择性实现</td>
</tr>
<tr>
<td align="left">列存</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">中</td>
<td align="left">低</td>
<td align="left">最简单</td>
</tr>
<tr>
<td align="left">文档存储</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">可选择性实现</td>
</tr>
<tr>
<td align="left">图存储</td>
<td align="left">可调整性能</td>
<td align="left">可选拓展</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">图理论</td>
</tr>
</tbody></table>
<p>键值存储通常采用<strong>树</strong>来组织键名，从而既支持读&#x2F;写&#x2F;删除操作，又友好支持遍历操作。通常采用树组织键名的顺序为<strong>字典序</strong>，可以按照字母顺序遍历键名。</p>
<p>键值存储基于CAP理论选择牺牲C（Consistency）、优化A（Availability）和P（Partition tolerance），从而可以选择实现从最终一致性（Eventual Consistency）到串行一致性（Serializability）的不同一致性模型。</p>
<h2 id="6-无"><a href="#6-无" class="headerlink" title="6. 无"></a>6. 无</h2><p>明确几个概念<br><strong>存储空间（Bucket）</strong>是用户用于存储对象（Object）的容器，即“桶”。所有对象都必须隶属于某个存储空间。它具有各种配置属性，包括地域、访问权限、存储类型等。</p>
<ul>
<li>同一个存储空间的内部是扁平的，没有文件系统的目录等概念，所有对象都直接隶属于其对应的存储空间。</li>
<li>每个用户可以拥有多个存储空间</li>
<li>存储空间的名称在对象存储服务范围内全局唯一，并且创建后无法修改存储空间的名称。</li>
<li>存储空间内部的对象数目没有限制。</li>
</ul>
<p><strong>对象（object）</strong>是对象存储服务存放数据的基本单元，也被称为对象存储服务的文件。对象由对象名（Key）、用户数据（Object Data）和元数据信息（Object Meta）组成。对象由存储空间内部唯一的对象名来标志，元数据信息是一组键值对，表示对象的属性，如最后修改时间、大小等信息，也可以自定义存储信息。</p>
<p>对象的生命是从上传成功到删除为止的，只有通过追加上传方式创建的对象能够不断增加数据内容，其他上传方式创建的对象无法直接修改写，但可以通过重复上传同名的对象来覆盖之前的对象。</p>
<p><strong>访问域名（Endpoint）</strong>表示对象存储服务器对外提供的域名，对象存储服务以HTTP&#x2F;HTTPS的RESTful API形式对外提供服务，当访问不同地域的时候，需要不同的域名，通过内网和外网访问对象存储OSS相同地域所对应的访问域名并不相同。</p>
<h2 id="7-数据迁移"><a href="#7-数据迁移" class="headerlink" title="7.数据迁移"></a>7.数据迁移</h2><p><img src="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.png" alt="数据迁移"></p>
<h3 id="镜像回源"><a href="#镜像回源" class="headerlink" title="镜像回源"></a>镜像回源</h3><p><strong>镜像回源功能，在业务读取OSS数据不存在时，将从源站抓取数据。</strong><br>步骤如下：</p>
<ol>
<li>迁移存量数据</li>
<li>配置镜像回源：在数据迁移过程中源站还在产生新数据</li>
<li>业务切换到OSS</li>
<li>迁移增量数据</li>
</ol>
<h2 id="8-安全与合规"><a href="#8-安全与合规" class="headerlink" title="8.安全与合规"></a>8.安全与合规</h2><p><img src="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%85%A8%E4%B8%8E%E5%90%88%E8%A7%84.png" alt="安全与合规"></p>
<h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><ul>
<li><strong>服务端加密（Server Side Encryption，SSE）</strong>，是指上传到云的链路是明文，数据保存是密文，从而保证存储数据的私密性的一种加密技术。技术上，对象存储OSS对收到的用户数据进行加密，然后将得到的加密数据持久化保存下来：下载数据时，OSS自动对保存的加密数据进行解密并把原始数据返回给用户，并在返回的HTTP请求Header中，对象存储声明该数据进行了服务端加密。</li>
<li><strong>客户端加密（Client Side Encryption，CSE）</strong>，是指为进一步加强私密性，在上传到云之前就进行加密，整个上云的链路、数据保存都是密文的一种加密技术。客户端加密需要客户端来管理加解密的密钥，服务端只把数据作为普通对象保存。客户端加密的安全性更高，但对客户端有较大性能影响。</li>
</ul>
<h2 id="9-数据保护"><a href="#9-数据保护" class="headerlink" title="9.数据保护"></a>9.数据保护</h2><p><img src="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4.png" alt="数据保护"></p>
<h3 id="数据持久性"><a href="#数据持久性" class="headerlink" title="数据持久性"></a>数据持久性</h3><p>数据持久性同时考虑了数据故障率。数据错误率，如11个9的持久性，就表示一万年的时间期限内，10MB数据只有1B数据有异常，表示该1B数据出现故障丢失或数据错误。</p>
<h3 id="服务可用性"><a href="#服务可用性" class="headerlink" title="服务可用性"></a>服务可用性</h3><p>对象存储OSS基于请求错误率模型提供可用性SLA，其标准型（同城冗余）存储的可用性SLA已经提升到99.995%。就是10万个请求中，最多只有5个请求返回服务端错误。</p>
<p>###版本控制<br>三种控制状态：</p>
<ul>
<li>未开启 </li>
<li>开启 对象存储OSS将为新上传的对象生成全局唯一的随机字符串版本ID</li>
<li>暂停 对象存储OSS将为新上传的对象生成特殊字符为“null”的版本ID</li>
</ul>
<h2 id="10-应用与实战"><a href="#10-应用与实战" class="headerlink" title="10.应用与实战"></a>10.应用与实战</h2><h3 id="对象元信息"><a href="#对象元信息" class="headerlink" title="对象元信息"></a>对象元信息</h3><p>分为两种：<strong>HTTP标准属性（HTTP Headers）和User Meta（用户自定义元信息）</strong></p>
<table>
<thead>
<tr>
<th align="left">元信息</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left">Content-Type</td>
<td align="left">指定对象的文件类型、编码等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Content-Encoding</td>
<td align="left">指定对象的压缩类型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Content-Language</td>
<td align="left">指定对象使用的语言</td>
</tr>
<tr>
<td align="left">HTTP标准属性</td>
<td align="left">Content-Disposition</td>
<td align="left">指定对象的展示形式incline&#x2F;attachment</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Cache-Control</td>
<td align="left">指定对象缓存配置</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Expires</td>
<td align="left">指定对象有效时间</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Last-Modified</td>
<td align="left">最后修改时间</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Content-Length</td>
<td align="left">大小</td>
</tr>
<tr>
<td align="left">User Meta</td>
<td align="left">以x-oss-meta-为前缀的参数</td>
<td align="left">总大小不超过8KB，会在读对象（GetObject）或读对象元数据（HeadObject）的时候在HTTP头部中返回</td>
</tr>
</tbody></table>
<h3 id="数据生命周期"><a href="#数据生命周期" class="headerlink" title="数据生命周期"></a>数据生命周期</h3><p>生命周期规则可以定期将非热点数据转换为<strong>低频访问</strong>、<strong>归档存储</strong>或<strong>冷归档存储</strong>，将不再需要访问的数据删除，从而使用户更高效地管理数据、节省成本。</p>
<p>生命周期规则包含以下三类信息：</p>
<ul>
<li><strong>匹配策略</strong>，匹配对象的名字、标签。<br>–  按前缀匹配，按指定前缀匹配对象和碎片。<br>– 按标签匹配，按指定标签的Key和Value匹配对象。<br>– 按前缀+标签匹配，按指定前缀和一个或多个标签的筛选条件匹配对象。<br>– 配置到整个存储空间，匹配整个存储空间内的所有对象和碎片。</li>
<li><strong>文件过期策略</strong>，设置对象的过期时间。<br>– 过期天数，指定一个过期天数N，对象会在其最后修改时间的N天后过期。<br>– 过期日期，指定一个过期日期，最后修改时间在该日期之前的对象全部过期。</li>
<li><strong>指定操作</strong>，设置文件过期后的动作。<br>–类型转换（Transition），将指定存储类型的对象转换为另外的存储类型。<br>–过期删除（Expire），将指定存储类型的过期对象按规则删除。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LifecycleConfiguration&gt;</span><br><span class="line">  &lt;Rule&gt;</span><br><span class="line">    &lt;ID&gt;test-rule0&lt;/ID&gt;</span><br><span class="line">    &lt;Prefix&gt;doc/&lt;/Prefix&gt;</span><br><span class="line">    &lt;Status&gt;Enabled&lt;/Status&gt;</span><br><span class="line">    &lt;Transition&gt;</span><br><span class="line">      &lt;Days&gt;180&lt;/Days&gt;</span><br><span class="line">      &lt;StorageClass&gt;IA&lt;/StorageClass&gt;</span><br><span class="line">    &lt;/Transition&gt;</span><br><span class="line">    &lt;Expiration&gt;</span><br><span class="line">      &lt;Days&gt;365&lt;/Days&gt;</span><br><span class="line">    &lt;/Expiration&gt;</span><br><span class="line">  &lt;/Rule&gt;</span><br><span class="line">&lt;LifecycleConfiguration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="上传对象"><a href="#上传对象" class="headerlink" title="上传对象"></a>上传对象</h3><ul>
<li><p>简单上传</p>
</li>
<li><p>表单上传</p>
</li>
<li><p><strong>分片上传和断点续传</strong><br><img src="https://upload-images.jianshu.io/upload_images/28940386-8461f3bae91ec49c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分片上传流程图"></p>
</li>
<li><p><strong>追加上传</strong><br>对象存储OSS的对象只能读取，不能修改。如果对象内容发生改变，只能重新上传同名对象进行覆盖。</p>
</li>
</ul>
<p>追加上传方式对象类型为<strong>Appendable Object</strong>（其他上传为Normal Object），每次追加上传的数据都能够即时可读。</p>
<ul>
<li>授权第三方上传<br>客户端直接上传文件到OSS，不需通过服务端转发。两种实现方式：URL签名和临时访问凭证。</li>
<li>上传回调<br>客户端上传对象到OSS后，OSS会向服务端主动发起HTTP请求进行回调，从而服务端就可以及时得到上传完成的通知并完成诸如数据库修改等操作，OSS收到服务端的回调请求响应后才会将状态返回给客户端。</li>
<li>RTMP推流上传</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="clibiqt1n0001ukxv0jxc8hna" data-title="对象存储实战指南学习笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RGW对象存储网关学习1：数据组织与存储" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/10/RGW%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A01%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E4%B8%8E%E5%AD%98%E5%82%A8/" class="article-date">
  <time class="dt-published" datetime="2023-04-10T08:43:04.000Z" itemprop="datePublished">2023-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/10/RGW%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A01%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E4%B8%8E%E5%AD%98%E5%82%A8/">RGW对象存储网关学习1：数据组织与存储</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="本文主要为rgw对象存储网关学习"><a href="#本文主要为rgw对象存储网关学习" class="headerlink" title="本文主要为rgw对象存储网关学习"></a>本文主要为rgw对象存储网关学习</h1><p>RADOS是一个基于对象的存储系统（这里的对象是指RADOS内部的一种数据存储单元，与对象存储中的对象概念有所区别）</p>
<h2 id="为什么需要RGW"><a href="#为什么需要RGW" class="headerlink" title="为什么需要RGW"></a>为什么需要RGW</h2><p>通常情况下应用通过RAODS抽象库librados提供的对象接口访问RADOS集群，但是librados只提供私有接口，并不支持HTTP协议访问。Ceph为了支持通用的HTTP接口设计了RGW（RADOS GateWay，即对象存储网关）系统。然后，如果RGW只提供通用的HTTP访问接口，应用需要花费较大的代价才能开发出适配RGW访问接口的软件，这不利于Ceph在云存储领域中迅速普及，因此RGW选择适配云存储领域中最广泛的Amazon S3和OpenStack Swift接口，使得现有的S3和Swift用户可以以较小的代价接入到Ceph提供的对象存储系统中。</p>
<p><strong>RGW实际上是Ceph专门为对象存储应用提供RESTful接口访问RADOS集群的一个访问通道，同时为了方便应用使用，其提供的RESTful接口兼容目前在云存储领域中应用的最广泛的Amazon S3系统和OpenStack Swift系统所提供的对象访问接口。</strong></p>
<h2 id="对象存储系统的基础数据实体："><a href="#对象存储系统的基础数据实体：" class="headerlink" title="对象存储系统的基础数据实体："></a>对象存储系统的基础数据实体：</h2><ul>
<li>用户</li>
<li>桶</li>
<li>对象</li>
</ul>
<hr>
<h3 id="用户："><a href="#用户：" class="headerlink" title="用户："></a>用户：</h3><p><strong>用户指的是对象存储的使用者，一个用户可以拥有一个或者多个存储桶。<br>一个用户对应一个RADOS对象。</strong></p>
<p>用户管理设计主要基于以下几个方面考虑：</p>
<ol>
<li>为了对RESTful API进行请求认证；</li>
<li>为了控制用户对资源（存储桶，对象等）的访问权限；</li>
<li>为了控制用户的可用存储空间。</li>
</ol>
<p>因此，一个用户包含的信息包括<strong>用户认证信息，访问控制权限信息和配额信息</strong>。</p>
<ul>
<li><p>用户认证信息</p>
<p>S3用户身份认证机制都是基于密钥认证的。认证过程如下：</p>
<p>发送请求前，使用用户私有密钥(secret_key)，请求内容等，采用与RGW网关约定好的算法计算出数字签名后，将数字签名以及用户访问密钥(access_key)封装在请求中发送给RGW网关</p>
</li>
</ul>
<p>RGW网关收到请求后，使用用户访问密钥作为索引从RADOS集群中读取用户信息，并从用户信息中获取用户私有密钥<br>使用用户私有密钥，请求内容等，采用与应用约定好的算法计算数字签名<br>判断RGW生成的数字签名和请求的前面是否匹配，匹配则用户通过验证</p>
<ul>
<li>访问控制权限信息</li>
<li>配额信息</li>
</ul>
<p>下表为RGWUserInfo数据结构</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left"></th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>user_id</code></td>
<td align="left"><code>Tenent </code></td>
<td align="left">用户所属租户，创建用户时指定，不指定的情况下，所有不指定租户的用户属于同一个租户</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Id</code></td>
<td align="left">用户ID，创建用户时指定</td>
</tr>
<tr>
<td align="left"><code>display_name</code></td>
<td align="left"></td>
<td align="left">用户名</td>
</tr>
<tr>
<td align="left"><code>user_email</code></td>
<td align="left"></td>
<td align="left">用户email地址</td>
</tr>
<tr>
<td align="left"><code>access_keys</code></td>
<td align="left"><code>Id</code></td>
<td align="left">用户访问密钥，用户身份认证时使用</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Key</code></td>
<td align="left">用户私有密码，用户身份认证时使用</td>
</tr>
<tr>
<td align="left"><code>swift_keys</code></td>
<td align="left"><code>Subuser</code></td>
<td align="left">子用户ID，创建子用户时指定</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Key</code></td>
<td align="left">子用户私有密钥，即Swift用户私有密钥</td>
</tr>
<tr>
<td align="left"><code>subusers</code></td>
<td align="left"><code>Name</code></td>
<td align="left">子用户ID</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>perm_mask</code></td>
<td align="left">子用户访问权限，包括<code>read、write、readwrite、full-control</code></td>
</tr>
<tr>
<td align="left"><code>Suspended</code></td>
<td align="left"></td>
<td align="left">用户被暂停访问</td>
</tr>
<tr>
<td align="left"><code>max_buckets</code></td>
<td align="left"></td>
<td align="left">用户可以创建的存储桶数目</td>
</tr>
<tr>
<td align="left"><code>op_mask</code></td>
<td align="left"></td>
<td align="left">用户操作访问权限，包括read、write、delete，可设置多个权限的组合，比如{read、write}或{read、write、delete}</td>
</tr>
<tr>
<td align="left"><code>Caps</code></td>
<td align="left"></td>
<td align="left">授权用户权限，授权用户根据授予的权限可以进行特殊的操作。<br><code>Caps</code>由一组<code>&lt;caps-type, perm&gt;</code>组成：<br><code>caps-type</code>指的是用户可访问的资源，有效值为：<code>users、buckets、metadata、usage、mdlog、datalog、opstate、bilog</code>；<br><code>perm</code>指的是用户对该资源具有什么权限，有效值为<code>read、write、readwrite、*</code>。<br>比如一个用户的<code>caps</code>设置为“<code>users=read</code>”，表示该用户具有查询其他用户信息的权限</td>
</tr>
<tr>
<td align="left"><code>bucket_quota</code></td>
<td align="left"><code>max_size</code></td>
<td align="left">限制单个存储桶下所有对象的总大小</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>max_objects</code></td>
<td align="left">限制单个存储桶下对象总数目</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>enabled</code></td>
<td align="left">该字段为布尔类型，值为<code>true</code>时，配额生效</td>
</tr>
<tr>
<td align="left"><code>user_quota</code></td>
<td align="left"><code>max_size</code></td>
<td align="left">限制该用户下所有对象的总大小</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>max_objects</code></td>
<td align="left">限制该用户下对象总数目</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>enabled</code></td>
<td align="left">该字段为布尔类型，值为<code>true</code>时，用户配额生效</td>
</tr>
</tbody></table>
<p>RGW将用户信息把保存在RADOS对象的数据部分，一个用户对应一个RADOS对象。由于大部分情况下我们需要使用用户ID作为索引获取用户信息，因此该对象以用户ID命名（RADOS通过‘‘pool名+对象’’来查询一个对象，后面解释pool）。</p>
<p>RGW需要将访问密钥，子用户，email和用户信息所在的RADOS对象建立索引关系，针对这种情况，RGW采用了二级索引的实现方式。即分别创建以用户访问密钥、子用户、email命名的三个RADOS对象（以下称索引对象），并且将用户ID保存在对象的数据部分。从而当需要使用某个索引查询用户信息时，首先从索引对象读出用户ID，然后使用用户ID作为索引读取用户信息。</p>
<hr>
<h3 id="桶"><a href="#桶" class="headerlink" title="桶:"></a>桶:</h3><p><strong>存储桶是对象的容器。一个存储桶对应一个RADOS对象。</strong></p>
<p>一个存储桶包含的信息分为两类：</p>
<ol>
<li>一类是对象RGW网关透明的信息，这类信息通常指用户自定义的元数据，RGW将这些信息保存在对象的扩展信息中，一个KV键值对对应一个扩展属性条目；</li>
<li>一类是RGW网关关注的信息，包括存储桶中对象的存储策略，存储桶中索引对象的数目以及应用对象与索引对象的映射关系、存储桶的配额等，这类信息由数据结构RGWBucketInfo管理，保存在RADOS对象的数据部分。</li>
</ol>
<p>下表为<code>RGWBucketInfo</code>关键字段</p>
<table>
<thead>
<tr>
<th align="left">成员</th>
<th align="left"></th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>owner</code></td>
<td align="left"></td>
<td align="left">存储桶的创建者或拥有者</td>
</tr>
<tr>
<td align="left"><code>placement_rule</code></td>
<td align="left"></td>
<td align="left">存储桶中的对象的存储策略，存储策略关联用户上传的对象、bucket索引对象、分段上传对象产生的中间数据存放的存储池。存储池的存储策略在创建存储桶时指定，创建后将不能修改</td>
</tr>
<tr>
<td align="left"><code>index_type</code></td>
<td align="left">0</td>
<td align="left">当创建一个桶时，同时创建一个或多个存储对象，并且在有应用对象更新时，将对象记录在其中一个索引对象中</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">当创建一个桶时，同时创建一个或多个存储对象，但是在有应用对象更新时，不记录对象</td>
</tr>
<tr>
<td align="left"><code>num_shards</code></td>
<td align="left"></td>
<td align="left">索引对象数目</td>
</tr>
<tr>
<td align="left"><code>quota</code></td>
<td align="left"></td>
<td align="left">存储桶配额</td>
</tr>
<tr>
<td align="left"><code>bucket_index_shard_hash_type</code></td>
<td align="left"></td>
<td align="left">当一个存储桶对应多个索引对象时，计算某个对象由哪个索引对象保存的算法，目前只支持一种算法：<br><code>索引对象=hash(object_name)%num_shards</code></td>
</tr>
</tbody></table>
<p>创建存储桶时，RGW网关会同步创建一个或多个索引对象，用于保存改存储桶下的对象列表，以支持查询存储桶对象列表(<code>List Bucket</code>)功能，因此在存储桶中有新的对象上传或者删除时必须更新索引对象。</p>
<p>RGW采用了Ceph通常采用的解决方案，将索引对象分片(<code>shard</code>)，把一个索引对象切分成多个对象，不同应用对象记录在不同的索引对象上。</p>
<p>这个方案极大的改观了对象的写性能，但是分片后带来的一个负面影响，会影响查询桶对象列表操作的性能。分片后原先只需要读一个索引对象就可以获取存储桶下对象列表变成了针对多个索引对象的读，这时，RGW网关与RADOS集群间的网络延时，多个索引对象查询结果的合并对查询存储桶对象列表性能产生很大的影响。</p>
<p>为了降低这个负面影响，RGW视图对多个索引对象并发读取代串行读，以降低查询存储桶对象列表操作的处理时间。但事物都有两面性，如果一味的增加索引对象的数目，与此同时归并排序所消耗的计算量和缓存也会增加，从而也制约了查询效率。</p>
<hr>
<h3 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h3><p><strong>对象是对象存储系统数据组织和存储的基本单位，一个对象包含数据和元数据。数据指的是用户保存的真正的数据，比如一个文本文件的内容或者一个视频文件的内容；元数据指的是除了数据外的其他需要保存的信息，一般由KV键值对组成。（类似于创建桶时的两类信息）</strong></p>
<p>与文件系统层级管理结构不同，对象存储系统中所有对象都以扁平方式存储，对象之间没有直接关联，这种特性很容易实现将不同的对象保存在不同的物理位置。此外，对象存储不提供编辑对象部分内容的功能，对象必须作为一个整体单元操作，即使只更新对象中的一个字符，也必须将整个对象从云端下载下来，更新后上传。</p>
<p>应用上传的对象包括数据和元数据两部分，数据部分保存在一个或者多个RADOS对象的数据部分，元素据保存在其中一个RADOS对象的扩展属性中。（为什么是一个或多个呢？因为前面提到的分片）</p>
<p>RGW对于单个对象提供了两种上传接口：整体上传和分段上传</p>
<ul>
<li><p>整体上传：</p>
<p>RGW限制了整体上传一个对象器大小不能大于5GB，当用户上传的对象大于该限制时必须分段上传，否则上传对象失败。为了更好理解用户上传对象和RADOS对象的对应关系，先了解两个值和一个类：</p>
<p><code>rgw_max_chunk_size</code>：该宏值用来表示RGW下发到RADOS集群单个I&#x2F;O的大小，同时决定应用对象分成多个RADOS对象时首对象的大小，以下简称分块大小</p>
<p><code>rgw_obj_stripe_size</code>：公司宏值用来指定当一个对象被分成多个RADOS对象时中间对象的大小，以下简称条带大小</p>
<p><code>Class RGWWObjManifest</code>：用来管理用户上传的对象和RADOS对象的对应关系，以下简称manifest</p>
<p>整体上传时，</p>
<ul>
<li>当对象小于分块时，用户上传的一个对象只对应一个RADOS对象，该RADOS对象以应用对象名称命名，对象元数据也保存在该RADOS对象的扩展属性中；</li>
<li>当用户上传的对象大于分块时，被分解成一个大小等于分块大小的首对象，多个大小等于条带大小的中间对象，和一个大小小于条带大小的尾对象。</li>
</ul>
</li>
<li><p>分段上传：</p>
<p>分段上传对象时，RGW网关按照条带大小将每个分段分成多个RADOS对象。当所有的分段上传结束以后，RGW会另外生成一个RADOS对象，用于保存应用对象元数据和所有分段的manifest。</p>
</li>
</ul>
<hr>
<h2 id="数据存储位置"><a href="#数据存储位置" class="headerlink" title="数据存储位置"></a>数据存储位置</h2><p>前面分析了RGW数据的组织和存储方式，不同的用户数据最终以RADOS对象为单位保存到了RADOS集群中。为了实现不同的应用数据存储位置的隔离，RGW使用zone来管理用户数据的存储位置，zone由一组存储池(pool)组成，不同存储池用来保存不同的数据，RGW使用数据结构<code>RGWZoneParams</code>来管理不同的存储池。因此配置一个RGW实例时，需要指定该RGW实例所属的zone以及确定数据的存储位置。</p>
<p>下表为<code>RGWZoneParams</code>关键字段</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>domain_root</code></td>
<td align="left">该存储池用来存储存储桶的信息</td>
</tr>
<tr>
<td align="left"><code>metadata_heap</code></td>
<td align="left">该存储池用来存储存储桶的信息和用户信息，可不配置</td>
</tr>
<tr>
<td align="left"><code>control_pool</code></td>
<td align="left">RGW实例上电时，在该存储池中创建若干个对象用于watch-notify，主要作用为当一个zone包含多个RGW实例启动了缓存功能时，保证所有RGW实例间数据一致性，其基本原理为利用librados提供的对象watch-notify功能，当有数据更新时，通知其他RGW实例更新本地缓存</td>
</tr>
<tr>
<td align="left"><code>gc_pool</code></td>
<td align="left">RGW实例上电时，在该存储池中创建多个对象，用于记录在后台删除的对象。RGW实例会定期启动gc线程，删除记录的对象</td>
</tr>
<tr>
<td align="left"><code>lc_pool</code></td>
<td align="left">S3 API支持对象生命周期（对象生命周期过后，系统会自动删除对象）功能，该存储池用来记录对象生命周期的执行状态</td>
</tr>
<tr>
<td align="left"><code>log_pool</code></td>
<td align="left">该存储池用来存储用户操作日志、数据同步日志等</td>
</tr>
<tr>
<td align="left"><code>usage_log_pool</code></td>
<td align="left">该存储池用来存储用户操作统计信息，比如对象上传次数、下载次数等</td>
</tr>
<tr>
<td align="left"><code>user_keys_pool</code></td>
<td align="left">该存储池用来存储用户访问密钥与用户ID的关系</td>
</tr>
<tr>
<td align="left"><code>user_email_pool</code></td>
<td align="left">该存储池用来存储用户email与用户ID的关系</td>
</tr>
<tr>
<td align="left"><code>user_swift_pool</code></td>
<td align="left">该存储池用来存储子用户与用户ID的关系</td>
</tr>
<tr>
<td align="left"><code>user_uid_pool</code></td>
<td align="left">该存储池用来存储用户信息和记录每个用户下存储列表信息</td>
</tr>
<tr>
<td align="left"><code>placement_pool</code></td>
<td align="left">应用对象的存储位置</td>
</tr>
</tbody></table>
<p>需要重点强调的是placement_pools字段。该字段由<code>map&lt;string,RGWZonePlacementInfo&gt;</code>组成，<code>string</code>是一个自定义字符串，可以认为是一个对象存储策略，用来唯一定位第二个字段<code>RGWZonePlacementInfo</code>。第二个字段主要定义应用对象的存储位置、用户分段上传对象时的中间数据的存储位置和存储索引对象的存储位置等。当创建一个存储桶时，用户可以显式指定zone中已存在的存储策略，后续往存储桶中上传对象时，将按照该存储策略存储对象。</p>
<p>下表为<code>RGWZonePlacementInfo</code>关键字段</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left"></th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>index_pool</code></td>
<td align="left"></td>
<td align="left">该存储池用来保存存储同的索引对象</td>
</tr>
<tr>
<td align="left"><code>data_pool</code></td>
<td align="left"></td>
<td align="left">该存储池用来保存应用上传的对象</td>
</tr>
<tr>
<td align="left"><code>data_extra_pool</code></td>
<td align="left"></td>
<td align="left">该存储池用来保存分段上传对象所产生的中间数据</td>
</tr>
<tr>
<td align="left"><code>index_type</code></td>
<td align="left">0</td>
<td align="left">该存储策略下将存储桶下对象记录在索引对象中</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1</td>
<td align="left">该存储策略下不记录存储桶下对象列表</td>
</tr>
<tr>
<td align="left"><code>compression_type</code></td>
<td align="left"></td>
<td align="left">当启动数据压缩时，指定压缩算法</td>
</tr>
</tbody></table>
<p>RGW数据分布 Conceptual view<br>“Although RADOS only knows about pools and objects with their xattrs and omap, conceptually RGW organizes its data into three defferent kinds: <strong>metadata</strong>, <strong>bucket index</strong>, and <strong>data</strong>.”<br>RGW 将其数据组织为三种不同的类型：元数据、存储桶索引和数据</p>
<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>有三部分元数据：user，bucket，bucket.instance</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ radosgw-admin metadata list</span><br><span class="line">$ radosgw-admin metadata list bucket</span><br><span class="line">$ radosgw-admin metadata list bucket.instance</span><br><span class="line">$ radosgw-admin metadata list user</span><br><span class="line"></span><br><span class="line">$ radosgw-admin metadata get bucket:&lt;bucket&gt;</span><br><span class="line">$ radosgw-admin metadata get bucket.instance:&lt;bucket&gt;:&lt;bucket_id&gt;</span><br><span class="line">$ radosgw-admin metadata get user:&lt;user&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bucket对应内部的类型是RGWBucketEntryPoint，其只保存的bucket概要信息。<br>bucket instance对应内部的数据类型是RGWBucketInfo，其保存的是bucket的详细信息。<br>user对应内部的RGWUserInfo，保存user的详细信息</p>
<h3 id="user元数据"><a href="#user元数据" class="headerlink" title="user元数据"></a>user元数据</h3><p>通过下面的命令可以查看某个用户的元信息，包括：id，name，key，quota等信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$radosgw-admin metadata user get user:&#123;user&#125;</span><br></pre></td></tr></table></figure>

<p>在逻辑上，user信息存储在{zone}.rgw.meta池的users:*命名空间中，如下：</p>
<ol>
<li>users.uid：存储用户id及其bucket信息</li>
<li>users.keys：存储用户的access key信息，通过它可以找到用户id</li>
<li>users.email：存储用户的email信息</li>
<li>users.swfit：存储swfit子用户信息</li>
</ol>
<p>其中用户的基本信息（<code>id，key，email，subuser</code>等）包含在结构<code>RGWUserInfo</code>中，用户的bucket信息包含在结构<code>cls_user_bucket_entry</code>中，还有其他结构也包含在<code>cls_user_types.h</code>文件中，详情可以参考源码，物理上，这些信息都存储在存储池映射的OSD磁盘上；下面是一个示例：</p>
<h3 id="users-uid命名空间"><a href="#users-uid命名空间" class="headerlink" title="users.uid命名空间"></a>users.uid命名空间</h3><ol>
<li><p>包含user和user.buckets两个对象，其中user包含用户的基本信息，user.buckets包含用户的bucket信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$rados ls -p &#123;zone&#125;.rgw.meta --namespace=users.uid</span><br></pre></td></tr></table></figure>
</li>
<li><p>user对象本身包含了用户的基本信息，基本上与用户相关的描述信息都包含在里面，只有一个扩展属性，没有omap属性。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$rados listxattr -p &#123;zone&#125;.rgw.meta --namespace=users.uid &#123;user&#125;</span><br><span class="line">$rados listomapkeys -p &#123;zone&#125;.rgw.meta --namespace=users.uid &#123;user&#125;</span><br><span class="line">$rados getxattr -p &#123;zone&#125;.rgw.meta --namespace=users.uid &#123;user&#125; &#123;key&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>user.buckets本身不包含信息，信息包含在omap属性中，没有扩展属性；用户在list bucket的时候会用到这个信息。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$rados listomapkeys -p &#123;zone&#125;.rgw.meta --namespace=users.uid &#123;user&#125;.buckets</span><br><span class="line"></span><br><span class="line">$rados getomapval -p &#123;zone&#125;.rgw.meta --namespace=users.uid &#123;user&#125;.buckets &#123;key&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="users-keys命名空间"><a href="#users-keys命名空间" class="headerlink" title="users.keys命名空间"></a>users.keys命名空间</h3><ul>
<li>包含了key到uid映射信息，可以通过access key找到uid。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>由于没有设置email和swift用户，所以users.email和users.swift空间没有记录相应的信息。<br>通过radosgw-admin user命令获取的所有信息都来至于上述的命名空间，各个命令的工作过程在这里就不相信分析了（掌握各操作的IO路径也是实现元数据分布式集群很重要的一部分，留待后面分析吧）</li>
</ul>
<h3 id="bucket元数据"><a href="#bucket元数据" class="headerlink" title="bucket元数据"></a>bucket元数据</h3><p>通过下面的命令可以查看某个桶的元信息，包含：name，key，marker等信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$radosgw-admin metadata bucket get bucket:&#123;bucket&#125;</span><br></pre></td></tr></table></figure>

<p>在逻辑上，<code>bucket</code>信息存储在<code>&#123;zone&#125;.rgw.meta</code>池的<code>root</code>命名空间中，其中<code>&#123;bucket&#125;</code> 记录了bucket与<code>instance_id</code>的对应关系，记录是的静态信息，对应于结构<code>RGWBucketEntryPoint</code>，<code>.bucket.meta.&#123;tenent&#125;：&#123;bucket&#125;:&#123;marker&#125; </code>记录bucket的寻址方式，记录的是动态信息，对应于结构RGWBucketInfo，bucket的ACL，Policy信息存放在xattr属性中，物理上，这些信息都存储在存储池映射的OSD磁盘上, 下面是一个示例：<br>1）包含bucket1和.bucket.meta.bucket1:475c3d39-2f37-4ffd-ab72-fecc7272339c.34580.1两个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rados ls master.rgw.meta --namespace=root all</span><br></pre></td></tr></table></figure>
<p>2）bucket1对象本身包含了用户的基本信息，基本上与用户相关的描述信息都包含在里面，只有一个扩展属性，没有omap属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$rados listxattr -p &#123;zone&#125;.rgw.meta --namespace=root &#123;bucket&#125;</span><br><span class="line">$rados listomapkeys -p &#123;zone&#125;.rgw.meta --namespace=root &#123;bucket&#125;</span><br><span class="line">$rados getxattr -p &#123;zone&#125;.rgw.meta --namespace=root &#123;bucket&#125; &#123;key&#125;</span><br></pre></td></tr></table></figure>

<p>3）.bucket.meta.bucket1:475c3d39-2f37-4ffd-ab72-fecc7272339c.34580.1对象的扩展属性中包含acl，policy等信息，对象本身包含bucket的动态信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$rados listxattr -p &#123;zone&#125;.rgw.meta --namespace=root .bucket.meta.&#123;tenent&#125;:&#123;bucket&#125;:&#123;marker&#125;</span><br><span class="line">ceph.obeclass.version</span><br><span class="line">user.rgw.acl</span><br><span class="line">$rados getxattr -p &#123;zone&#125;.rgw.meta --namespace=root .bucket.meta.&#123;tenent&#125;:&#123;bucket&#125;:&#123;marker&#125; user.rgw.acl</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rados get -p &#123;zone&#125;.rgw.meta --namespace=root .bucket.meta.&#123;tenent&#125;:&#123;bucket&#125;:&#123;marker&#125; </span><br></pre></td></tr></table></figure>


<h3 id="Bucket-Index"><a href="#Bucket-Index" class="headerlink" title="Bucket Index"></a>Bucket Index</h3><ul>
<li>一种特殊的元数据，单独保存。</li>
<li>bucket_index保存rados对象间的key-value map。</li>
<li>map信息保存在rados对象的omap属性中。</li>
</ul>
<p>通过下面的命令可以枚举bucket下的对象信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radosgw-admin bucket list --bucket=&#123;bucket&#125;</span><br></pre></td></tr></table></figure>
<p>在逻辑上，bucket index信息存储在<code>&#123;zone&#125;.rgw.buckets.index</code>池中，bucket index用于维护bucket下的对象信息，存储在一个或者多个对象的omap中 - key为对象的名字，value为结构<code>rgw_bucket_dir_entry</code>。bucket index对象的命名为：<code>.dir.&#123;bucket_id&#125;.&#123;shard_id&#125;</code>。下面是一个示例：<br>1）omap keys：bucket index对象中包含的object key列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rados listomapkeys -p &#123;zone&#125;.rgw.buckets.index .dir.&#123;bucket_id&#125;.&#123;shard_id&#125;</span><br></pre></td></tr></table></figure>

<p>2）omap value: 某个object的信息，对应结构<code>rgw_bucket_dir_entry</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$rados getomapval -p &#123;zone&#125;.rgw.buckets.index .dir.&#123;bucket_id&#125;.&#123;shard_id&#125; &#123;key&#125;</span><br></pre></td></tr></table></figure>

<p>3）omap header： 当前bucket index对象下的统计信息，对象数，总大小等。对应结构<code>rgw_bucket_dir_header</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$rados getomapheader -p &#123;zone&#125;.rgw.bucket.index .dir.&#123;bucket_id&#125;.&#123;shard_id&#125; &#123;key&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Data："><a href="#Data：" class="headerlink" title="Data："></a>Data：</h2><p>对象存储Object的数据存储在：<code>&#123;zone&#125;.rgw.buckets.data</code>池中。一个rgw对象包含一个或者多个rados对象.</p>
<p><img src="/2023/04/10/RGW%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A01%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E4%B8%8E%E5%AD%98%E5%82%A8/%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%85%B1%E8%AF%86.jpg" alt="共识和复制对比"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/10/RGW%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A01%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E4%B8%8E%E5%AD%98%E5%82%A8/" data-id="clibiqt1j0000ukxvag7m6z8r" data-title="RGW对象存储网关学习1：数据组织与存储" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/31/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">对象存储实战指南学习笔记</a>
          </li>
        
          <li>
            <a href="/2023/04/10/RGW%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3%E5%AD%A6%E4%B9%A01%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E4%B8%8E%E5%AD%98%E5%82%A8/">RGW对象存储网关学习1：数据组织与存储</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Bowen Zhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>